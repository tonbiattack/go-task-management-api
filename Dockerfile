# =============================================================================
# ビルドステージ（マルチステージビルドの第1段階）
# =============================================================================
# Goの公式イメージをベースとして使用
# golang:1.20-alpine は軽量なLinuxディストリビューション（Alpine Linux）をベースとした
# Go 1.20の開発環境を提供します
# AS builderで名前を付けることで、後段でこのステージを参照できます
FROM golang:1.20-alpine AS builder

# =============================================================================
# 作業ディレクトリの設定
# =============================================================================
# コンテナ内で作業を行うディレクトリを /app に設定
# この後のCOPYやRUNコマンドは全てこのディレクトリで実行されます
WORKDIR /app

# =============================================================================
# 依存関係の管理（Go Modules）
# =============================================================================
# go.mod と go.sum ファイルをコンテナにコピー
# go.mod: プロジェクトの依存関係とGoのバージョンを定義
# go.sum: 依存関係の整合性チェック用のハッシュ値を保存
# 先にこれらのファイルだけをコピーすることで、
# ソースコードが変更されても依存関係に変更がなければ
# Dockerのキャッシュ機能により依存関係のダウンロードをスキップできます
COPY go.mod go.sum ./

# Go Modulesの依存関係をダウンロード
# go mod downloadコマンドで、go.modに記載された全ての依存関係を
# $GOPATH/pkg/mod にダウンロードしてキャッシュします
RUN go mod download

# =============================================================================
# ソースコードのコピーとビルド
# =============================================================================
# プロジェクトの全ファイルをコンテナにコピー
# "." は現在のディレクトリ（Dockerfileのあるディレクトリ）を表します
# 最初の "." がホスト側、2番目の "." がコンテナ内の現在のディレクトリ（/app）
COPY . .

# Goアプリケーションをコンパイルしてバイナリファイルを生成
# CGO_ENABLED=0: CGO（C言語との連携機能）を無効化。静的リンクのバイナリを生成
# GOOS=linux: ターゲットOSをLinuxに指定（クロスコンパイル対応）
# go build: Goプログラムをコンパイルするコマンド
# -a: 全てのパッケージを強制的に再ビルド
# -installsuffix cgo: CGOが無効の場合に使用するサフィックス
# -o main: 出力ファイル名を "main" に指定
# .: カレントディレクトリのmain.goをビルド対象として指定
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# =============================================================================
# 実行ステージ（マルチステージビルドの第2段階）
# =============================================================================
# 本番環境で実行するための軽量なベースイメージ
# Alpine Linuxは非常に軽量（約5MB）なLinuxディストリビューションで、
# セキュリティアップデートも頻繁に提供される、コンテナに最適化されたOSです
FROM alpine:latest

# =============================================================================
# 必要なパッケージのインストール
# =============================================================================
# Alpine Linuxのパッケージマネージャー（apk）を使用してパッケージをインストール
# --no-cache: パッケージキャッシュをローカルに保存しない（イメージサイズ削減）
# ca-certificates: HTTPS通信で必要なCA証明書バンドル
# tzdata: タイムゾーン情報。日本時間など特定のタイムゾーンを使用する場合に必要
RUN apk --no-cache add ca-certificates tzdata

# =============================================================================
# 実行環境の設定
# =============================================================================
# 実行時の作業ディレクトリを /root/ に設定
# Alpine Linuxのデフォルトユーザーはrootのためrootのホームディレクトリを使用
WORKDIR /root/

# =============================================================================
# アプリケーションバイナリのコピー
# =============================================================================
# ビルドステージで作成したバイナリファイルを実行ステージにコピー
# --from=builder: 先ほど定義したbuilderステージからファイルをコピー
# /app/main: ビルドステージで作成されたバイナリファイルのパス
# .: カレントディレクトリ（/root/）にコピー
COPY --from=builder /app/main .

# =============================================================================
# ネットワーク設定
# =============================================================================
# コンテナが8080番ポートで通信することをDockerに通知
# 実際のポートマッピングは docker run 時の -p オプションで行います
# この指定はドキュメント的な意味が強く、
# どのポートでサービスが動作するかを明示する役割があります
EXPOSE 8080

# =============================================================================
# アプリケーションの起動
# =============================================================================
# コンテナ起動時に実行されるデフォルトコマンド
# ./main バイナリファイルを実行してアプリケーションを開始
# CMDはDockerfileでは1つしか有効にならず、最後のCMDが使用されます
# 配列形式（exec form）で記述することで、シェルを経由せず直接実行されるため、
# プロセスがPID 1で動作し、シグナルハンドリングが適切に行われます
CMD ["./main"]