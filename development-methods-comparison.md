# Go開発手法比較：ローカル vs Docker vs ホットリロード

このプロジェクトで利用可能な開発手法を比較し、それぞれのメリット・デメリットを解説します。

## 開発手法一覧

### 1. ローカル開発（Launch Go App Local）

**概要**：
- ホスト環境で直接Goアプリケーションを実行
- MySQLのみDocker（localhost:3306）

**メリット**：
- 🚀 **最高速度の起動・実行**：コンパイル時間とコンテナ起動時間がない
- 🔧 **シンプルなデバッグ**：VSCodeのGoデバッガーが直接動作
- 💻 **軽量リソース**：Dockerオーバーヘッドなし
- 🎯 **即座のコード変更反映**：保存と同時に反映

**デメリット**：
- ⚠️ **環境依存**：ホストのGo環境に依存
- 🔄 **手動再起動必要**：コード変更時の手動ビルド・実行
- 🏠 **本番環境との差異**：Dockerコンテナとの動作差異リスク

**適用場面**：
- 短時間の機能開発・デバッグ
- パフォーマンステスト
- Go初心者の学習

---

### 2. Docker通常デバッグ（Remote Debug Docker Container）

**概要**：
- デバッグ情報付きでビルドされたコンテナ
- Delveリモートデバッグサーバー使用
- コード変更時はコンテナ再ビルドが必要

**メリット**：
- 🏭 **本番環境に近い**：Dockerコンテナで実行
- 🔒 **環境の一貫性**：開発者間で同一環境
- 🛡️ **セキュリティ**：非rootユーザーで実行
- 🔍 **安定したデバッグ**：リモートデバッグが確実に動作

**デメリット**：
- ⏱️ **再ビルド時間**：コード変更毎に数分のビルド時間
- 🔄 **手動操作多い**：stop → rebuild → start の繰り返し
- 💾 **リソース消費**：ビルドプロセスでCPU・メモリ使用

**適用場面**：
- 本番環境での問題調査
- コンテナ固有の問題デバッグ
- 安定した長時間デバッグセッション

---

### 3. ホットリロード開発（Remote Debug + Hot Reload）

**概要**：
- Airツールによる自動ビルド・再実行
- Delveデバッグサーバーと組み合わせ
- ソースコードをマウントして即座に反映

**メリット**：
- ⚡ **自動再ビルド**：コード保存で即座に反映（1-2秒）
- 🔍 **継続的デバッグ**：コード変更してもデバッグセッション継続
- 🏭 **本番環境近似**：Dockerコンテナで実行
- 🔄 **開発効率最大**：手動操作なしで開発サイクル高速化
- 📦 **Go modulesキャッシュ**：依存関係の再ダウンロード不要

**デメリット**：
- 🔧 **初期セットアップ複雑**：Air設定ファイル、Dockerfile設定が必要
- 💾 **メモリ使用量増加**：Airプロセス + アプリプロセス
- ⚠️ **デバッグ複雑性**：Air経由のデバッグで追加レイヤー
- 🐛 **潜在的不安定性**：ファイル監視システムの誤動作可能性

**適用場面**：
- **メイン開発手法**：日常的な機能開発
- API開発・テスト
- フロントエンドとの連携開発
- 長時間の開発セッション

---

## 詳細技術比較

### パフォーマンス比較

| 項目 | ローカル | Docker通常 | ホットリロード |
|------|----------|------------|----------------|
| 初回起動時間 | 2-3秒 | 30-60秒 | 15-30秒 |
| コード変更反映 | 手動（5-10秒） | 手動（2-5分） | 自動（1-2秒） |
| メモリ使用量 | 50-100MB | 200-300MB | 250-400MB |
| CPU使用率 | 低 | 中 | 中～高 |

### 開発体験比較

| 項目 | ローカル | Docker通常 | ホットリロード |
|------|----------|------------|----------------|
| デバッグ品質 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 開発速度 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 環境一貫性 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| セットアップ簡単さ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |

### Airホットリロードの技術詳細

**Air設定のポイント**：
```toml
[build]
  cmd = "dlv debug --headless --listen=:2345 --api-version=2 --accept-multiclient"
  include_ext = ["go", "tpl", "tmpl", "html"]
  exclude_regex = ["_test.go"]
  delay = 1000  # 1秒の遅延でファイル変更の重複を防ぐ
```

**ホットリロードの動作フロー**：
1. ファイル変更検知（inotify/fsnotify）
2. 既存プロセス終了
3. 新しいバイナリビルド
4. Delveデバッグサーバー起動
5. VSCodeが自動再接続

---

## 推奨使い分け

### 🚀 日常開発：ホットリロード
- API機能追加・修正
- データベース連携開発
- バグ修正

### 🔍 詳細調査：Docker通常デバッグ
- 本番環境での問題再現
- パフォーマンス問題調査
- コンテナ固有の動作確認

### ⚡ 簡単テスト：ローカル開発
- 単純な関数テスト
- アルゴリズム検証
- 学習・実験

---

## ホットリロード開発のベストプラクティス

### 1. 効率的な開発フロー
```bash
# 開始
vscode -> F5 -> "Remote Debug + Hot Reload"

# 開発サイクル
コード編集 -> 保存(Ctrl+S) -> 自動ビルド(1-2秒) -> テスト
```

### 2. トラブルシューティング
- **Airが反応しない**：tmpディレクトリの権限確認
- **デバッグ接続失敗**：ポート2345の競合確認
- **ビルドエラー継続**：`docker-compose logs app-hotreload`でログ確認

### 3. パフォーマンス最適化
- `.air.toml`のexclude設定でビルド対象ファイル最適化
- Go modulesキャッシュボリュームでダウンロード時間短縮
- tmpディレクトリのボリュームマウントでI/O高速化

## まとめ

**ホットリロード開発が最も効率的**な理由：
- ✅ 本番環境と同等の実行環境
- ✅ コード変更の即座反映（1-2秒）
- ✅ 継続的なデバッグセッション
- ✅ 手動操作の最小化

初期セットアップは複雑ですが、**一度設定すれば最も生産性の高い開発環境**を提供します。